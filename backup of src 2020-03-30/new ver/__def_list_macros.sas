/*
 * RRG: statistical reporting system.
 *  
 * This file is part of the RRG project (https://github.com/ipeszek/RRG) which is released under GNU General Public License v3.0.
 * You can use RRG source code for statistical reporting but not to create for-profit selleable product. 
 * See the LICENSE file in the root directory or go to https://www.gnu.org/licenses/gpl-3.0.en.html for full license details.
 */

%macro __def_list_macros/store;
  
data _null_;
file "&rrgpgmpath./&rrguri.0.sas" mod;
put;
put;
put @1 "*---------------------------------------------------------------------;";
PUT @1 "* DEFINE MACRO THAT SPLITS STRING INTO MUPLTIPLE LINES;";
PUT @1 "* USING '|' AND PADDING WITH BLANKS, SO THAT INDENTATION IS MAINTAINED;";
put @1 "*---------------------------------------------------------------------;";
PUT;
PUT;
put @1 '%macro __splitstr(string=, len=);';
put @1 '%local string len;';
put;
put @1 'length __tmpf2 __tmpf __tmp0  $ 2000;';
put @1 'length __tmp1 __tmp __tmpw $ 2000;';
put;
put @1 '%* split string at the tab positions;';
put @1 '__tmp0 = tranwrd(strip(&string), "//", byte(12));';
put @1 '__tabsize=0;';
put @1 '__tmpf2="";';
put @1 'do while (__tmp0 ne "");';
put @1 '  __tabpos = index(__tmp0, "/t");';
put @1 '  if __tabpos<=0 then do;';
put @1 '     __tmpf2 = strip(__tmpf2)||strip(__tmp0);';
put @1 '   __tmp0 = "";';
put @1 '  end;';
put @1 '  else do;';
put @1 '     __tabsize = __tabsize+input(substr(__tmp0, __tabpos+2,1), best.);';
put @1 "     __padx = repeat(byte(11), &indentsize*__tabsize-1);";
put @1 '     if __tabpos>1 then do;';
put @1 '       if __tmpf2 = "" then __tmpf2 = strip(substr(__tmp0, 1, __tabpos-1))||byte(12)||strip(__padx);';
put @1 '       else __tmpf2 = strip(__tmpf2)||strip(substr(__tmp0, 1, __tabpos-1))||byte(12)||strip(__padx);';
put @1 '     end;';
put @1 '     else  do;';
put @1 '       if __tmpf2 = "" then __tmpf2 = byte(12)||strip(__padx);';
put @1 '       else __tmpf2 = strip(__tmpf2)||byte(12)||strip(__padx);';
put @1 '     end;';
put @1 '     __tmp0 = strip(substr(__tmp0, __tabpos+3));';
put @1 '   __tmp0 = tranwrd(strip(__tmp0), byte(12), byte(12)||strip(__padx));';
put @1 '  end;';
put @1 'end;';
put @1 '__tmpf="";';
put;
put @1 'do __j=1 to countw(__tmpf2, byte(12));';
put;  
put @1 '    __tmp1=strip(scan(__tmpf2,__j,byte(12)));';
put @1 '    __padnum = count(__tmp1, byte(11));';
put @1 '    __tmp1 = substr(__tmp1,__padnum+1);';
put @1 '    __tmp="";';
put @1 '    __spaceleft = &len-__padnum;';
put @1 '    __cw = countw(__tmp1, " ");';
put @1 '    do __i=1 to __cw;';
put @1 '       __tmpl = length(scan(__tmp1,__i," "));';
put @1 '       if __tmpl>&len-__padnum then do;';
put @1 '          __tmpw = scan(__tmp1, __i, " ");';
put @1 '          if __spaceleft<=1 then do;';
put @1 '            __tmp = strip(__tmp)||"|"||substr(__tmpw,1,&len);';
put @1 '            if length(__tmpw)>&len then  __tmpw = substr(__tmpw, &len+1);';
put @1 '            else __tmpw="";';
put @1 '            __spaceleft=&len-__padnum;';
put @1 '          end;';
put @1 '          else do;';
put @1 '            __tmp = strip(__tmp)||" "||substr(__tmpw,1,__spaceleft-1);';
put @1 '            __tmpw = substr(__tmpw, __spaceleft);';
put @1 '            __spaceleft =&len-__padnum;';
put @1 '          end;';
put @1 '          do while (__tmpw ne "");';
put @1 '            if length(__tmpw)>=__spaceleft then do;';
put @1 '               __tmp = strip(__tmp)||"|"||substr(__tmpw,1,__spaceleft);';
put @1 '               if length(__tmpw)>__spaceleft then __tmpw = substr(__tmpw, __spaceleft+1);';
put @1 '               else __tmpw="";';
put @1 '            end;';
put @1 '            else do;';
put @1 '               __tmp = strip(__tmp)||"|"||substr(__tmpw,1);';
put @1 '               __tmpw="";';
put @1 '            end;';
put @1 '            __spaceleft=&len-__padnum;';
put @1 '          end;';
put @1 '       end;';
put @1 '       else do;';
put @1 '       if __tmp ne "" then __mod=1;';
put @1 '       else __mod=0;';
put @1 '         if __spaceleft-__mod-__tmpl<0 then do;';
put @1 '            %* word does not fit;';
put @1 '            __tmp = strip(__tmp)||"|"||scan(__tmp1,__i," ");';
put @1 '            __spaceleft = &len - __padnum - __tmpl;';
put ;
put @1 '         end; ';
put @1 '         else do;';
put @1 '           %*word fits;';
put @1 '           if __tmp ne "" then do;';
put @1 '              __tmp = strip(__tmp)||" "||scan(__tmp1,__i," ");';
put @1 '              __spaceleft = __spaceleft-1-__tmpl - __padnum;';
put @1 '           end;';
put @1 '           else do;';
put @1 '              __tmp = scan(__tmp1,__i," ");';
put @1 '              __spaceleft = __spaceleft-__tmpl - __padnum;';
put @1 '           end;';
put @1 '         end;';
put @1 '       end;';
put @1 '    end;';
put ;    
put @1 '    if __padnum>0 then do;';
put @1 '      __pad="|"||repeat(byte(11),__padnum-1);;';
put @1 '      __tmp = repeat(byte(11),__padnum-1)||tranwrd(strip(__tmp),"|", strip(__pad)); ';
put @1 '    end;';
put ;
put @1 '  if __tmpf="" then __tmpf = strip(__tmp);';
put @1 '  else __tmpf = strip(__tmpf)||"|"||strip(__tmp);';
put;
put @1 'end;';
put ;
put @1 '&string = tranwrd(strip(__tmpf), byte(11), byte(160));';
put @1 '** try 183 also;';
put;
put @1 '%mend;';
put;
put;
put @1 "*---------------------------------------------------------------------;";
PUT @1 "* DEFINE MACRO THAT CALCULATES NUMBER OF DIGITS BEFORE DECIMAL POINT;";
put @1 "*---------------------------------------------------------------------;";
PUT;
PUT;
put @1 '%macro __getpads(string=);';
put @1 '%* __tl = number of digits before decimal point;';
put @1 '%local string;';
put @1 '__tmpgp= strip(&string);';
put @1 "__tmpsep = compress(__tmpgp,'1234567890-.');";
put @1 "__tmpsep = strip(__tmpsep)||byte(160);";
put @1 "__tmpgp= scan(__tmpgp,1,strip(__tmpsep)||' ');";
put @1 'if __tmpgp="" or anydigit(__tmpgp)<=0 then __tl =0;';
put @1 'else do;';
put @1 '  __tl = index(__tmpgp, ".");';
put @1 '  if __tl<=0 then __tl=length(__tmpgp); ';
put @1 '  else __tl = __tl-1;';
put @1 'end;';
put @1 '%mend;';
put;
put @1 '%macro __getpadsRD(string=);';
put;
put @1 '%* __tl = number of digits before decimal point;';
put @1 '%* __tl2 = number of digits before decimal point for second number;';
put @1 '%local string;';
put @1 'length __w1 __w2 $ 2000 ;';
put @1 "__tmpsep = byte(160)||' ';";
put @1 "__w1='';";
put @1 "__w2='';";
put @1 '__tmpgp= strip(&string);';
/*
put "do __cnt = 1 to length(__tmpgp);";
put "  xx= rank(substr(__tmpgp, __cnt,1));";
put "  put __tmpgp= xx=;";
put "end;";
*/
put @1 "__w1=scan(__tmpgp,1,__tmpsep);";
put @1 "__w2=scan(__tmpgp,2,__tmpsep);";
put;

put @1 'if __w1="" or anydigit(__w1)<=0 then __tl =0;';
put @1 'else do;';
put @1 '  __tl = index(__w1, ".");';
put @1 '  if __tl<=0 then __tl=length(__w1); ';
put @1 '  else __tl = __tl-1;';
put @1 'end;';
put;
put @1 'if __w2="" or anydigit(__w2)<=0 then __tl2 =0;';
put @1 'else do;';
put @1 '  __tl2 = index(__w2, ".");';
put @1 '  if __tl2<=0 then __tl2=length(__w2); ';
put @1 '  else __tl2 = __tl2-1;';
put @1 'end;';
put @1 '%mend;';
put;
run;
%mend;
